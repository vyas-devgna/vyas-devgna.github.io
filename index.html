<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NOMAD MESH</title>
    <!-- PeerJS (Free Signaling) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #ffffff;
            --fg: #000000;
            --border: #000000;
            --gray: #e0e0e0;
            --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font);
            margin: 0;
            padding: 0;
            height: 100vh; /* Fallback */
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- UTILITY --- */
        .hidden { display: none !important; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .grow { flex-grow: 1; }
        .bold { font-weight: bold; }
        .border { border: 2px solid var(--border); }
        .p-2 { padding: 12px; }
        
        button {
            background: var(--bg);
            color: var(--fg);
            border: 2px solid var(--border);
            padding: 12px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 14px;
            cursor: pointer;
            border-radius: 0;
            touch-action: manipulation;
        }
        button:active { background: var(--fg); color: var(--bg); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        input {
            border: 2px solid var(--border);
            padding: 10px;
            font-size: 16px; /* Prevents zoom on iOS */
            border-radius: 0;
            outline: none;
        }

        /* --- SCREENS --- */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg);
            z-index: 999;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            padding: 20px;
        }

        #app-layout {
            display: flex;
            flex-direction: row;
            height: 100%;
            width: 100%;
        }

        /* --- SIDEBAR (PEERS) --- */
        #sidebar {
            width: 260px;
            border-right: 2px solid var(--border);
            display: flex; flex-direction: column;
            background: var(--bg);
            z-index: 10;
        }

        #peer-list {
            overflow-y: auto;
            flex-grow: 1;
        }

        .peer-item {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-family: monospace;
            font-size: 14px;
        }

        .peer-label { display: flex; align-items: center; gap: 10px; cursor: pointer; width: 100%; }
        input[type="checkbox"] { width: 20px; height: 20px; margin: 0; }

        .status-dot {
            width: 10px; height: 10px; background: #fff; border: 1px solid #000; border-radius: 50%;
        }
        .status-dot.online { background: #000; }

        /* --- CHAT AREA --- */
        #chat-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: #f8f8f8;
        }

        #header {
            height: 50px;
            border-bottom: 2px solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 15px;
            background: var(--bg);
        }

        #messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 80px; /* Space for input */
        }

        .msg-bubble {
            max-width: 85%;
            padding: 10px 15px;
            border: 2px solid var(--border);
            background: var(--bg);
            position: relative;
            box-shadow: 3px 3px 0px rgba(0,0,0,1);
        }
        
        .msg-own {
            align-self: flex-end;
            background: #000;
            color: #fff;
            border-color: #000;
        }
        
        .msg-meta {
            font-size: 10px;
            margin-bottom: 4px;
            text-transform: uppercase;
            opacity: 0.7;
        }

        #input-area {
            height: 60px;
            border-top: 2px solid var(--border);
            background: var(--bg);
            display: flex;
            width: 100%;
        }
        #msg-input { flex-grow: 1; border: none; padding: 15px; }
        #send-btn { border: none; border-left: 2px solid var(--border); width: 80px; font-weight: 900; }

        /* --- MOBILE ADAPTATION --- */
        @media (max-width: 768px) {
            #app-layout { flex-direction: column; }
            #sidebar { 
                width: 100%; 
                height: auto; 
                max-height: 35vh; 
                border-right: none; 
                border-bottom: 2px solid var(--border);
                order: 2; /* Put sidebar at bottom or top? Let's put top but collapsible maybe. For now, top fixed height. */
                display: none; /* Hide sidebar by default on mobile to focus on chat */
            }
            #sidebar.open { display: flex; position: absolute; top: 50px; bottom: 0; left: 0; right: 0; height: auto; max-height: none; }
            
            #mobile-menu-btn { display: block !important; }
            #chat-container { height: 100%; }
        }

        #mobile-menu-btn { display: none; font-size: 20px; background: none; border: none; padding: 0; }

        /* --- CALL OVERLAY --- */
        #call-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95);
            z-index: 2000;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        .pulse { animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <!-- 1. LOGIN SCREEN -->
    <div id="login-screen">
        <h1 style="border: 4px solid black; padding: 15px; margin-bottom: 40px; box-shadow: 8px 8px 0px #000;">NOMAD MESH</h1>
        <div style="width: 100%; max-width: 300px; display: flex; flex-direction: column; gap: 10px;" id="identity-buttons">
            <!-- Buttons injected by JS -->
        </div>
        <p style="margin-top: 20px; font-size: 12px; color: #666;">Offline-First • P2P • No Server</p>
    </div>

    <!-- 2. MAIN APP -->
    <div id="app-layout" class="hidden">
        
        <!-- SIDEBAR -->
        <div id="sidebar">
            <div class="p-2 border-bottom" style="background: #000; color: #fff; display: flex; justify-content: space-between; align-items: center;">
                <span id="my-id-display" class="bold">User</span>
                <button onclick="app.logout()" style="padding: 5px; font-size: 10px; border: 1px solid white; background: black; color: white;">LOGOUT</button>
            </div>
            
            <div style="padding: 10px; border-bottom: 2px solid var(--border); font-size: 12px; background: #eee;">
                STATUS: <span id="conn-status">CONNECTING...</span>
            </div>

            <div id="peer-list">
                <!-- Peers go here -->
            </div>

            <div style="padding: 10px; border-top: 2px solid var(--border);">
                <button onclick="app.startCall()" style="width: 100%; background: #000; color: #fff;">START AUDIO CALL</button>
            </div>
        </div>

        <!-- CHAT -->
        <div id="chat-container">
            <div id="header">
                <button id="mobile-menu-btn" onclick="app.toggleSidebar()">☰ PEERS</button>
                <span class="bold">TEAM CHAT</span>
                <div style="width: 20px;"></div>
            </div>

            <div id="messages">
                <div style="text-align: center; color: #999; margin-top: 50px;">History is empty</div>
            </div>

            <div id="input-area">
                <input type="text" id="msg-input" placeholder="Type a message..." autocomplete="off">
                <button id="send-btn" onclick="app.sendMessage()">SEND</button>
            </div>
        </div>
    </div>

    <!-- 3. CALL OVERLAY -->
    <div id="call-overlay" class="hidden">
        <h2 id="call-status" style="margin-bottom: 30px; font-size: 24px;">INCOMING CALL</h2>
        
        <div id="call-controls" style="display: flex; gap: 20px; flex-direction: column; width: 80%; max-width: 300px;">
            <button id="btn-accept" onclick="app.acceptCall()" style="background: black; color: white; padding: 20px;">ACCEPT</button>
            <button id="btn-decline" onclick="app.endCall()" style="padding: 20px;">DECLINE / END</button>
            <button id="btn-mute" class="hidden" onclick="app.toggleMute()" style="border-style: dashed;">MUTE</button>
        </div>
        <div id="participants-display" style="margin-top: 20px; font-family: monospace;"></div>
    </div>

    <!-- HIDDEN AUDIO CONTAINER -->
    <div id="audio-root"></div>

<script>
/**
 * NOMAD MESH - Production Ready P2P
 */

const CONFIG = {
    peers: [
        "DevgnaVyas00", "YashPandya11", "PrathamSukhadia22",
        "MilanSharma33", "TirthPrajapati44", "NishitRana55"
    ],
    dbName: "NomadMeshV2",
    store: "chats"
};

const state = {
    myId: null,
    peer: null,
    conns: {}, // Data Channels
    mediaCalls: {}, // Audio Calls
    localStream: null,
    db: null,
    activeCall: false,
    participants: new Set(),
    isMuted: false
};

// --- DATABASE (IndexedDB) ---
const DB = {
    init: () => new Promise((resolve, reject) => {
        const req = indexedDB.open(CONFIG.dbName, 1);
        req.onupgradeneeded = e => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(CONFIG.store)) {
                db.createObjectStore(CONFIG.store, { keyPath: 'id' });
            }
        };
        req.onsuccess = e => {
            state.db = e.target.result;
            resolve();
        };
        req.onerror = e => console.error("DB Error", e);
    }),
    save: (msg) => {
        if (!state.db) return;
        const tx = state.db.transaction(CONFIG.store, 'readwrite');
        tx.objectStore(CONFIG.store).put(msg);
    },
    load: () => new Promise(resolve => {
        if (!state.db) return resolve([]);
        const tx = state.db.transaction(CONFIG.store, 'readonly');
        const req = tx.objectStore(CONFIG.store).getAll();
        req.onsuccess = () => resolve(req.result);
    })
};

// --- APP LOGIC ---
const app = {
    init: async () => {
        await DB.init();
        
        // Check for existing session
        const savedId = localStorage.getItem('nomad_id');
        if (savedId && CONFIG.peers.includes(savedId)) {
            app.login(savedId);
        } else {
            app.renderLogin();
        }
    },

    renderLogin: () => {
        const container = document.getElementById('identity-buttons');
        container.innerHTML = '';
        CONFIG.peers.forEach(id => {
            const btn = document.createElement('button');
            btn.innerText = id;
            btn.onclick = () => app.login(id);
            container.appendChild(btn);
        });
        document.getElementById('login-screen').classList.remove('hidden');
        document.getElementById('app-layout').classList.add('hidden');
    },

    login: (id) => {
        state.myId = id;
        localStorage.setItem('nomad_id', id); // PERSISTENCE
        
        document.getElementById('login-screen').classList.add('hidden');
        document.getElementById('app-layout').classList.remove('hidden');
        document.getElementById('my-id-display').innerText = id;
        
        app.renderPeerList();
        app.loadMessages();
        app.startNetwork();
    },

    logout: () => {
        localStorage.removeItem('nomad_id');
        window.location.reload();
    },

    toggleSidebar: () => {
        const sb = document.getElementById('sidebar');
        if (sb.classList.contains('open')) {
            sb.classList.remove('open');
            sb.style.display = 'none'; // Force hide on mobile
        } else {
            sb.classList.add('open');
            sb.style.display = 'flex'; // Force show
        }
    },

    renderPeerList: () => {
        const list = document.getElementById('peer-list');
        list.innerHTML = '';
        CONFIG.peers.forEach(pid => {
            if (pid === state.myId) return;
            const div = document.createElement('div');
            div.className = 'peer-item';
            div.innerHTML = `
                <label class="peer-label">
                    <input type="checkbox" value="${pid}">
                    <span class="status-dot" id="dot-${pid}"></span>
                    <span>${pid}</span>
                </label>
            `;
            list.appendChild(div);
        });
    },

    loadMessages: async () => {
        const msgs = await DB.load();
        // Sort by timestamp
        msgs.sort((a,b) => a.ts - b.ts);
        const container = document.getElementById('messages');
        container.innerHTML = '';
        msgs.forEach(app.renderMessageBubble);
        app.scrollChat();
    },

    renderMessageBubble: (msg) => {
        const container = document.getElementById('messages');
        const div = document.createElement('div');
        const isMe = msg.from === state.myId;
        div.className = `msg-bubble ${isMe ? 'msg-own' : ''}`;
        
        const time = new Date(msg.ts).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        div.innerHTML = `
            <div class="msg-meta">${isMe ? 'ME' : msg.from} • ${time}</div>
            <div>${app.escape(msg.text)}</div>
        `;
        container.appendChild(div);
        app.scrollChat();
    },

    scrollChat: () => {
        const el = document.getElementById('messages');
        el.scrollTop = el.scrollHeight;
    },

    // --- NETWORK ---
    startNetwork: () => {
        state.peer = new Peer(state.myId);
        
        state.peer.on('open', () => {
            document.getElementById('conn-status').innerText = "ONLINE (MESH READY)";
            document.getElementById('conn-status').style.color = "green";
            app.connectAll();
        });

        state.peer.on('connection', conn => {
            app.setupConn(conn);
        });

        state.peer.on('call', call => {
            // Incoming Audio Call
            if(state.activeCall) {
                // If we are already in a call, auto-answer (Mesh logic)
                call.answer(state.localStream);
                app.handleMediaCall(call);
            } else {
                // Ringing
                state.incomingCall = call; // store temporary
                state.participants.add(call.peer); // Assume they are in
                app.showCallUI("INCOMING CALL FROM " + call.peer, false);
            }
        });

        state.peer.on('error', err => {
            console.warn(err);
            // Auto retry logic handled by PeerJS internal mostly, but we can warn UI
        });
    },

    connectAll: () => {
        // Try to connect to everyone for chat
        CONFIG.peers.forEach(pid => {
            if (pid === state.myId) return;
            const conn = state.peer.connect(pid);
            app.setupConn(conn);
        });
    },

    setupConn: (conn) => {
        conn.on('open', () => {
            state.conns[conn.peer] = conn;
            const dot = document.getElementById(`dot-${conn.peer}`);
            if(dot) dot.classList.add('online');
        });

        conn.on('data', data => {
            if (data.type === 'CHAT') {
                app.handleChat(data.payload);
            } else if (data.type === 'INVITE') {
                // Conference invite
                if(state.activeCall) return; // Busy
                state.participants = new Set(data.peers);
                app.showCallUI(`GROUP CALL (${data.peers.length})`, false);
            }
        });

        conn.on('close', () => {
            const dot = document.getElementById(`dot-${conn.peer}`);
            if(dot) dot.classList.remove('online');
            delete state.conns[conn.peer];
        });
    },

    // --- MESSAGING ---
    sendMessage: () => {
        const input = document.getElementById('msg-input');
        const text = input.value.trim();
        if (!text) return;

        const msg = {
            id: Date.now() + Math.random().toString(),
            from: state.myId,
            text: text,
            ts: Date.now()
        };

        DB.save(msg);
        app.renderMessageBubble(msg);
        
        // Broadcast
        Object.values(state.conns).forEach(conn => {
            if(conn.open) conn.send({type: 'CHAT', payload: msg});
        });

        input.value = '';
    },

    handleChat: (msg) => {
        DB.save(msg);
        // Only render if not exists (simple dedupe)
        app.renderMessageBubble(msg);
    },

    // --- AUDIO CALLS ---
    startCall: async () => {
        const selected = Array.from(document.querySelectorAll('#peer-list input:checked')).map(cb => cb.value);
        if (selected.length === 0) return alert("Select peers first!");

        selected.push(state.myId);
        state.participants = new Set(selected);

        try {
            state.localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        } catch(e) { return alert("Microphone access denied"); }

        app.showCallUI("CALLING...", true);

        // Notify others to join
        selected.forEach(pid => {
            if (pid === state.myId) return;
            if (state.conns[pid]) {
                state.conns[pid].send({ type: 'INVITE', peers: selected });
            }
            // Dial them
            const call = state.peer.call(pid, state.localStream);
            app.handleMediaCall(call);
        });
    },

    acceptCall: async () => {
        try {
            state.localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        } catch(e) { return alert("Microphone access denied"); }

        app.showCallUI("CONNECTED", true);

        // Answer specific incoming if exists
        if (state.incomingCall) {
            state.incomingCall.answer(state.localStream);
            app.handleMediaCall(state.incomingCall);
            state.incomingCall = null;
        }

        // Dial everyone else in the group (Mesh)
        state.participants.forEach(pid => {
            if (pid === state.myId) return;
            if (!state.mediaCalls[pid]) {
                const call = state.peer.call(pid, state.localStream);
                app.handleMediaCall(call);
            }
        });
    },

    handleMediaCall: (call) => {
        state.mediaCalls[call.peer] = call;
        call.on('stream', stream => {
            if(!document.getElementById(`audio-${call.peer}`)) {
                const audio = document.createElement('audio');
                audio.id = `audio-${call.peer}`;
                audio.srcObject = stream;
                audio.autoplay = true;
                document.getElementById('audio-root').appendChild(audio);
                app.updateCallList();
            }
        });
        call.on('close', () => {
            const el = document.getElementById(`audio-${call.peer}`);
            if(el) el.remove();
            delete state.mediaCalls[call.peer];
            app.updateCallList();
        });
    },

    showCallUI: (status, isActive) => {
        const ui = document.getElementById('call-overlay');
        ui.classList.remove('hidden');
        document.getElementById('call-status').innerText = status;
        
        state.activeCall = isActive;

        if (isActive) {
            document.getElementById('btn-accept').classList.add('hidden');
            document.getElementById('btn-mute').classList.remove('hidden');
        } else {
            document.getElementById('btn-accept').classList.remove('hidden');
            document.getElementById('btn-mute').classList.add('hidden');
        }
        app.updateCallList();
    },

    updateCallList: () => {
        const display = document.getElementById('participants-display');
        const activePeers = Object.keys(state.mediaCalls);
        if (activePeers.length > 0) {
            display.innerHTML = "Talking with: <br>" + activePeers.join('<br>');
        } else {
            display.innerHTML = "Waiting for peers...";
        }
    },

    toggleMute: () => {
        state.isMuted = !state.isMuted;
        state.localStream.getAudioTracks()[0].enabled = !state.isMuted;
        document.getElementById('btn-mute').innerText = state.isMuted ? "UNMUTE" : "MUTE";
        document.getElementById('btn-mute').style.background = state.isMuted ? "red" : "transparent";
    },

    endCall: () => {
        if(state.localStream) {
            state.localStream.getTracks().forEach(t => t.stop());
            state.localStream = null;
        }
        Object.values(state.mediaCalls).forEach(c => c.close());
        state.mediaCalls = {};
        state.activeCall = false;
        document.getElementById('call-overlay').classList.add('hidden');
        document.getElementById('audio-root').innerHTML = '';
    },

    escape: (str) => {
        const d = document.createElement('div');
        d.innerText = str;
        return d.innerHTML;
    }
};

window.onload = app.init;
</script>
</body>
</html>