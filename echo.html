<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GHOST_BOARD // P2P</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- QR Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

    <!-- Icons (Lucide) -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        ghost: {
                            bg: '#050505',
                            surface: '#111111',
                            border: '#333333',
                            text: '#e0e0e0',
                            neon: '#2aff2a',
                            danger: '#ff2a2a',
                            warn: '#ffcc00'
                        }
                    },
                    fontFamily: {
                        mono: ['"Courier New"', 'Courier', 'monospace']
                    },
                    cursor: {
                        crosshair: 'crosshair',
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #050505;
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden; /* Prevent pull-to-refresh */
        }
        
        /* Strict No Radius Rule */
        * {
            border-radius: 0 !important;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #111;
        }
        ::-webkit-scrollbar-thumb {
            background: #333;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Ghost Button Styles */
        .btn-ghost {
            background: transparent;
            border: 1px solid #333;
            color: #e0e0e0;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .btn-ghost:hover {
            background: #1a1a1a;
            border-color: #555;
            color: #fff;
        }
        .btn-ghost:active {
            background: #2aff2a;
            color: #000;
            border-color: #2aff2a;
        }
        .btn-ghost.danger:hover {
            border-color: #ff2a2a;
            color: #ff2a2a;
        }
        .btn-ghost.active {
            background: #333;
            border-color: #e0e0e0;
        }

        /* Canvas Grid Background */
        #canvas-container {
            background-image: 
                radial-gradient(#222 1px, transparent 1px),
                radial-gradient(#111 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            touch-action: none;
        }

        /* CRT Scanline Effect Overlay (Subtle) */
        .scanlines::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 9999;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col scanlines relative">

    <!-- ========================================== -->
    <!-- AUDIO / COMMS HEADER (Always Visible)      -->
    <!-- ========================================== -->
    <header class="h-12 bg-ghost-surface border-b border-ghost-border flex items-center justify-between px-4 z-50 shrink-0">
        <div class="flex items-center gap-4">
            <span class="text-ghost-neon font-bold tracking-widest text-lg">GHOST_BOARD</span>
            <div id="status-badge" class="text-[10px] border border-ghost-border px-2 py-0.5 text-ghost-warn tracking-widest bg-black/50">
                [ OFFLINE ]
            </div>
        </div>

        <div class="flex items-center gap-2 h-full py-2">
            <!-- Visualizer Canvas -->
            <canvas id="audio-viz" width="100" height="24" class="bg-black border border-ghost-border hidden md:block"></canvas>
            
            <button id="btn-mic" class="btn-ghost h-full px-3 text-[10px]" title="TOGGLE MIC">
                <i data-lucide="mic"></i>
            </button>
            <button id="btn-speaker" class="btn-ghost h-full px-3 text-[10px]" title="TOGGLE AUDIO">
                <i data-lucide="volume-2"></i>
            </button>
            <button id="btn-exit" class="btn-ghost h-full px-3 text-[10px] text-ghost-danger hidden" title="DISCONNECT">
                <i data-lucide="log-out"></i>
            </button>
        </div>
    </header>

    <!-- ========================================== -->
    <!-- VIEW: LOBBY                                -->
    <!-- ========================================== -->
    <main id="view-lobby" class="flex-1 flex flex-col items-center justify-center p-4 z-40 bg-ghost-bg">
        <div class="w-full max-w-md bg-ghost-surface border border-ghost-border p-6 flex flex-col gap-6">
            <div class="text-center space-y-2">
                <h1 class="text-2xl text-white tracking-widest">IDENTITY_VERIFIED</h1>
                <p class="text-xs text-gray-500 font-mono uppercase">Secure P2P Protocol Initialized</p>
            </div>

            <!-- My ID Section -->
            <div class="flex flex-col items-center gap-4 py-4 border-y border-ghost-border border-dashed">
                <canvas id="qr-code" class="border-4 border-white"></canvas>
                <div class="flex gap-2 w-full">
                    <div class="flex-1 bg-black border border-ghost-border p-3 text-center text-xl text-ghost-neon tracking-[0.2em] font-bold" id="my-peer-id">
                        ----
                    </div>
                    <button id="btn-copy" class="btn-ghost px-4" title="COPY LINK">
                        <i data-lucide="copy"></i>
                    </button>
                </div>
                <p class="text-[10px] text-gray-600 uppercase">Share this ID or QR to connect</p>
            </div>

            <!-- Connect Section -->
            <div class="space-y-4">
                <div class="flex gap-2">
                    <input type="text" id="input-peer-id" placeholder="ENTER TARGET ID" 
                        class="flex-1 bg-black border border-ghost-border p-3 text-ghost-text placeholder-gray-700 outline-none uppercase font-mono focus:border-ghost-neon">
                    <button id="btn-connect" class="btn-ghost px-6 font-bold text-ghost-neon border-ghost-neon">
                        CONNECT
                    </button>
                </div>
                
                <div class="relative">
                    <div class="absolute inset-0 flex items-center">
                        <div class="w-full border-t border-ghost-border"></div>
                    </div>
                    <div class="relative flex justify-center text-xs uppercase">
                        <span class="bg-ghost-surface px-2 text-gray-500">OR</span>
                    </div>
                </div>

                <button id="btn-scan" class="btn-ghost w-full py-3 gap-2">
                    <i data-lucide="scan-line"></i> SCAN QR CODE
                </button>
                
                <div id="scanner-container" class="hidden w-full h-64 bg-black border border-ghost-border relative">
                    <div id="reader" class="w-full h-full"></div>
                    <button id="btn-close-scanner" class="absolute top-2 right-2 btn-ghost bg-black/80 px-2 py-1 text-xs text-red-500 z-10">X</button>
                </div>
            </div>
        </div>
    </main>

    <!-- ========================================== -->
    <!-- VIEW: WHITEBOARD                           -->
    <!-- ========================================== -->
    <main id="view-board" class="flex-1 relative hidden h-full overflow-hidden">
        
        <!-- Canvas Layer -->
        <div id="canvas-container" class="absolute inset-0 z-0">
            <canvas id="drawing-canvas"></canvas>
        </div>

        <!-- Tools Interface (Floating) -->
        <div class="absolute bottom-6 left-1/2 transform -translate-x-1/2 flex gap-2 p-2 bg-ghost-surface/90 border border-ghost-border backdrop-blur-sm z-10">
            
            <!-- Colors -->
            <div class="flex gap-1 pr-4 border-r border-ghost-border mr-2">
                <button class="color-btn w-8 h-8 border border-white bg-white" data-color="#ffffff"></button>
                <button class="color-btn w-8 h-8 border border-ghost-neon bg-ghost-neon" data-color="#2aff2a"></button>
                <button class="color-btn w-8 h-8 border border-red-500 bg-red-500" data-color="#ff2a2a"></button>
                <button class="color-btn w-8 h-8 border border-blue-500 bg-blue-500" data-color="#2a2aff"></button>
                <button class="color-btn w-8 h-8 border border-yellow-400 bg-yellow-400" data-color="#ffcc00"></button>
            </div>

            <!-- Tools -->
            <button id="tool-eraser" class="btn-ghost w-10 h-8" title="ERASER">
                <i data-lucide="eraser"></i>
            </button>
            <button id="tool-wipe" class="btn-ghost w-10 h-8 text-ghost-danger hover:border-ghost-danger" title="WIPE BOARD">
                <i data-lucide="trash-2"></i>
            </button>
            <button id="tool-save" class="btn-ghost w-10 h-8 text-ghost-neon hover:border-ghost-neon" title="SAVE IMAGE">
                <i data-lucide="download"></i>
            </button>
        </div>
    </main>

    <!-- Scripts -->
    <script>
        // Initialize Icons
        lucide.createIcons();

        /* =========================================
           1. UI CONTROLLER
           ========================================= */
        class UIManager {
            constructor() {
                this.views = {
                    lobby: document.getElementById('view-lobby'),
                    board: document.getElementById('view-board')
                };
                this.badges = {
                    status: document.getElementById('status-badge'),
                    idDisplay: document.getElementById('my-peer-id')
                };
                this.scannerContainer = document.getElementById('scanner-container');
                this.canvas = document.getElementById('audio-viz');
                this.canvasCtx = this.canvas.getContext('2d');
            }

            showBoard() {
                this.views.lobby.classList.add('hidden');
                this.views.board.classList.remove('hidden');
                document.getElementById('btn-exit').classList.remove('hidden');
                // Trigger resize
                window.dispatchEvent(new Event('resize'));
            }

            showLobby() {
                this.views.board.classList.add('hidden');
                this.views.lobby.classList.remove('hidden');
                document.getElementById('btn-exit').classList.add('hidden');
                this.updateStatus('DISCONNECTED', 'gray');
            }

            updateStatus(text, colorType) {
                const colors = {
                    green: 'text-ghost-neon border-ghost-neon',
                    red: 'text-ghost-danger border-ghost-danger',
                    amber: 'text-ghost-warn border-ghost-warn',
                    gray: 'text-gray-500 border-gray-500'
                };
                this.badges.status.className = `text-[10px] border px-2 py-0.5 tracking-widest bg-black/50 transition-colors ${colors[colorType] || colors.gray}`;
                this.badges.status.innerText = `[ ${text} ]`;
            }

            setMyId(id) {
                this.badges.idDisplay.innerText = id;
                // Generate QR
                new QRious({
                    element: document.getElementById('qr-code'),
                    value: `${window.location.origin}${window.location.pathname}?peer=${id}`,
                    size: 150,
                    background: '#000000',
                    foreground: '#ffffff',
                    level: 'L'
                });
            }

            toggleScanner(show) {
                if (show) this.scannerContainer.classList.remove('hidden');
                else this.scannerContainer.classList.add('hidden');
            }

            drawVisualizer(dataArray) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                this.canvasCtx.clearRect(0, 0, width, height);
                
                const barWidth = (width / dataArray.length) * 2.5;
                let barHeight;
                let x = 0;

                for(let i = 0; i < dataArray.length; i++) {
                    barHeight = dataArray[i] / 255 * height;
                    this.canvasCtx.fillStyle = `rgb(42, 255, 42)`; // Neon Green
                    this.canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
        }

        /* =========================================
           2. NETWORK MANAGER (WebRTC)
           ========================================= */
        class NetworkManager {
            constructor(app) {
                this.app = app;
                this.peer = null;
                this.conn = null;
                this.call = null;
                this.localStream = null;
                this.remoteStream = null;
                this.isMuted = false;
                
                // Audio Context
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioCtx.createAnalyser();
                this.analyser.fftSize = 64; // Low res for retro look
            }

            init() {
                // Generate short ID
                const randomId = 'GHOST-' + Math.random().toString(36).substr(2, 4).toUpperCase();
                
                this.peer = new Peer(randomId, {
                    debug: 2
                });

                this.peer.on('open', (id) => {
                    console.log('My peer ID is: ' + id);
                    this.app.ui.setMyId(id);
                    this.app.ui.updateStatus('ONLINE', 'green');
                    this.app.checkDeepLink();
                });

                this.peer.on('connection', (conn) => {
                    this.handleConnection(conn);
                });

                this.peer.on('call', (call) => {
                    console.log('Incoming call...');
                    this.answerCall(call);
                });

                this.peer.on('error', (err) => {
                    console.error(err);
                    this.app.ui.updateStatus('ERROR', 'red');
                    alert('Connection Error: ' + err.type);
                });
            }

            connect(remoteId) {
                if (!remoteId) return;
                this.app.ui.updateStatus('CONNECTING...', 'amber');
                const conn = this.peer.connect(remoteId);
                this.handleConnection(conn);
                this.initiateCall(remoteId);
            }

            handleConnection(conn) {
                this.conn = conn;

                this.conn.on('open', () => {
                    this.app.ui.updateStatus(`LINKED: ${this.conn.peer}`, 'green');
                    this.app.ui.showBoard();
                    // Send initial sync request if needed
                });

                this.conn.on('data', (data) => {
                    this.app.handleData(data);
                });

                this.conn.on('close', () => {
                    this.app.ui.updateStatus('PEER LEFT', 'red');
                    setTimeout(() => this.app.ui.showLobby(), 2000);
                    this.cleanup();
                });
            }

            send(data) {
                if (this.conn && this.conn.open) {
                    this.conn.send(data);
                }
            }

            // --- Audio Handling ---

            async getLocalStream() {
                if (this.localStream) return this.localStream;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    this.localStream = stream;
                    this.connectStreamToVisualizer(stream);
                    return stream;
                } catch (err) {
                    console.error('Mic access denied', err);
                    return null;
                }
            }

            connectStreamToVisualizer(stream) {
                const source = this.audioCtx.createMediaStreamSource(stream);
                source.connect(this.analyser);
                this.app.startVisualizerLoop();
            }

            async initiateCall(remoteId) {
                const stream = await this.getLocalStream();
                if (!stream) return;
                
                this.call = this.peer.call(remoteId, stream);
                this.handleCallStream(this.call);
            }

            async answerCall(call) {
                const stream = await this.getLocalStream();
                call.answer(stream || undefined); // Answer even if no mic, just to hear
                this.handleCallStream(call);
            }

            handleCallStream(call) {
                call.on('stream', (remoteStream) => {
                    // Play remote audio
                    const audio = new Audio();
                    audio.srcObject = remoteStream;
                    audio.play();
                    
                    // Add remote to visualizer (mixed)
                    const source = this.audioCtx.createMediaStreamSource(remoteStream);
                    source.connect(this.analyser); // Also visualize remote audio
                    source.connect(this.audioCtx.destination); // Output to speakers
                });
            }

            toggleMic() {
                if(this.localStream) {
                    this.isMuted = !this.isMuted;
                    this.localStream.getAudioTracks()[0].enabled = !this.isMuted;
                    return !this.isMuted; // Return active state
                }
                return false;
            }

            cleanup() {
                if (this.conn) this.conn.close();
                if (this.call) this.call.close();
                this.conn = null;
                this.call = null;
            }
        }

        /* =========================================
           3. WHITEBOARD LOGIC
           ========================================= */
        class Whiteboard {
            constructor(app) {
                this.app = app;
                this.canvas = document.getElementById('drawing-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('canvas-container');
                
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                
                // Config
                this.color = '#ffffff';
                this.lineWidth = 2;
                this.mode = 'draw'; // draw | eraser

                this.setupCanvas();
                this.addListeners();
            }

            setupCanvas() {
                // Resize Observer for full responsiveness
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = this.container.clientWidth;
                this.canvas.height = this.container.clientHeight;
                
                // Re-apply styles after resize
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
            }

            getPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;
                
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) / this.canvas.width, // Normalize 0-1
                    y: (clientY - rect.top) / this.canvas.height
                };
            }

            startDraw(e) {
                this.isDrawing = true;
                const pos = this.getPos(e);
                this.lastX = pos.x;
                this.lastY = pos.y;
            }

            draw(e) {
                if (!this.isDrawing) return;
                e.preventDefault(); // Stop scrolling on touch

                const pos = this.getPos(e);
                
                // Draw locally
                this.drawLine(this.lastX, this.lastY, pos.x, pos.y, this.color, this.mode === 'eraser');

                // Send to peer
                this.app.net.send({
                    type: 'draw',
                    x0: this.lastX,
                    y0: this.lastY,
                    x1: pos.x,
                    y1: pos.y,
                    color: this.color,
                    isEraser: this.mode === 'eraser'
                });

                this.lastX = pos.x;
                this.lastY = pos.y;
            }

            stopDraw() {
                this.isDrawing = false;
            }

            drawLine(x0, y0, x1, y1, color, isEraser) {
                const w = this.canvas.width;
                const h = this.canvas.height;

                this.ctx.beginPath();
                this.ctx.moveTo(x0 * w, y0 * h);
                this.ctx.lineTo(x1 * w, y1 * h);
                
                if (isEraser) {
                    this.ctx.globalCompositeOperation = 'destination-out';
                    this.ctx.lineWidth = 20;
                } else {
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 2;
                }
                
                this.ctx.stroke();
                this.ctx.closePath();
                
                // Reset composite
                this.ctx.globalCompositeOperation = 'source-over';
            }

            wipe() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            save() {
                // Create a temporary canvas to composite black background
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tCtx = tempCanvas.getContext('2d');
                
                // Fill black
                tCtx.fillStyle = '#050505';
                tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                // Draw original
                tCtx.drawImage(this.canvas, 0, 0);
                
                const link = document.createElement('a');
                link.download = `GHOST_BOARD_${Date.now()}.png`;
                link.href = tempCanvas.toDataURL();
                link.click();
            }

            addListeners() {
                // Mouse
                this.canvas.addEventListener('mousedown', (e) => this.startDraw(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDraw());
                this.canvas.addEventListener('mouseout', () => this.stopDraw());

                // Touch
                this.canvas.addEventListener('touchstart', (e) => this.startDraw(e), {passive: false});
                this.canvas.addEventListener('touchmove', (e) => this.draw(e), {passive: false});
                this.canvas.addEventListener('touchend', () => this.stopDraw());
            }
        }

        /* =========================================
           4. MAIN APPLICATION
           ========================================= */
        class App {
            constructor() {
                this.ui = new UIManager();
                this.net = new NetworkManager(this);
                this.board = new Whiteboard(this);
                
                this.net.init();
                this.setupControls();
            }

            handleData(data) {
                if (data.type === 'draw') {
                    this.board.drawLine(data.x0, data.y0, data.x1, data.y1, data.color, data.isEraser);
                } else if (data.type === 'wipe') {
                    this.board.wipe();
                }
            }

            checkDeepLink() {
                const params = new URLSearchParams(window.location.search);
                const targetPeer = params.get('peer');
                if (targetPeer) {
                    // Remove param from URL without reload
                    window.history.replaceState({}, document.title, window.location.pathname);
                    // Connect
                    document.getElementById('input-peer-id').value = targetPeer;
                    this.net.connect(targetPeer);
                }
            }

            startVisualizerLoop() {
                const loop = () => {
                    if (this.ui.canvas.offsetParent !== null) { // Only draw if visible
                        const bufferLength = this.net.analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);
                        this.net.analyser.getByteFrequencyData(dataArray);
                        this.ui.drawVisualizer(dataArray);
                    }
                    requestAnimationFrame(loop);
                };
                loop();
            }

            setupControls() {
                // Connection
                document.getElementById('btn-copy').addEventListener('click', () => {
                    const url = `${window.location.origin}${window.location.pathname}?peer=${this.net.peer.id}`;
                    navigator.clipboard.writeText(url);
                    const btn = document.getElementById('btn-copy');
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = '<span class="text-xs font-bold text-ghost-neon">COPIED</span>';
                    setTimeout(() => btn.innerHTML = originalHTML, 2000);
                });

                document.getElementById('btn-connect').addEventListener('click', () => {
                    const id = document.getElementById('input-peer-id').value.trim().toUpperCase();
                    this.net.connect(id);
                });

                document.getElementById('btn-exit').addEventListener('click', () => {
                    this.net.cleanup();
                    window.location.reload();
                });

                // Scanner
                document.getElementById('btn-scan').addEventListener('click', () => {
                    this.ui.toggleScanner(true);
                    this.startScanner();
                });
                document.getElementById('btn-close-scanner').addEventListener('click', () => {
                    if(this.html5QrCode) this.html5QrCode.stop();
                    this.ui.toggleScanner(false);
                });

                // Tools
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.board.color = e.target.dataset.color;
                        this.board.mode = 'draw';
                        // Visual selection feedback
                        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('ring-2', 'ring-white'));
                        e.target.classList.add('ring-2', 'ring-white');
                        document.getElementById('tool-eraser').classList.remove('active');
                    });
                });

                document.getElementById('tool-eraser').addEventListener('click', (e) => {
                    this.board.mode = 'eraser';
                    e.currentTarget.classList.add('active');
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('ring-2', 'ring-white'));
                });

                document.getElementById('tool-wipe').addEventListener('click', () => {
                    if(confirm('CONFIRM WIPE SYSTEM?')) {
                        this.board.wipe();
                        this.net.send({type: 'wipe'});
                    }
                });

                document.getElementById('tool-save').addEventListener('click', () => {
                    this.board.save();
                });

                // Audio
                document.getElementById('btn-mic').addEventListener('click', (e) => {
                    const isActive = this.net.toggleMic();
                    const btn = e.currentTarget;
                    if (isActive) {
                        btn.classList.add('text-ghost-neon', 'border-ghost-neon');
                        btn.innerHTML = '<i data-lucide="mic"></i>';
                    } else {
                        btn.classList.remove('text-ghost-neon', 'border-ghost-neon');
                        btn.innerHTML = '<i data-lucide="mic-off"></i>';
                    }
                    lucide.createIcons();
                });
            }

            startScanner() {
                this.html5QrCode = new Html5Qrcode("reader");
                const config = { fps: 10, qrbox: { width: 250, height: 250 } };
                
                this.html5QrCode.start({ facingMode: "environment" }, config, (decodedText) => {
                    // Success
                    console.log(`Scan result: ${decodedText}`);
                    
                    // Parse URL param if it's a full URL, or just take the ID
                    let peerId = decodedText;
                    if(decodedText.includes('?peer=')) {
                        const url = new URL(decodedText);
                        peerId = url.searchParams.get('peer');
                    }
                    
                    if(peerId) {
                        document.getElementById('input-peer-id').value = peerId;
                        this.html5QrCode.stop();
                        this.ui.toggleScanner(false);
                        this.net.connect(peerId);
                    }
                }, (errorMessage) => {
                    // parsing failure, ignore
                }).catch(err => {
                    console.error("Error starting scanner", err);
                    alert("Camera permission denied or error.");
                    this.ui.toggleScanner(false);
                });
            }
        }

        // Initialize on load
        window.addEventListener('load', () => {
            const app = new App();
        });

    </script>
</body>
</html>
