<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IMMERSIVE P2P UNO 3D</title>
    
    <!-- LIBRARIES -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* UI OVERLAY */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }
        
        /* LOBBY */
        #lobby-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.95); z-index: 10; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; color: white;
        }
        .btn {
            background: linear-gradient(135deg, #ff5555, #cc0000);
            border: 2px solid white; color: white; padding: 15px 40px; 
            font-size: 18px; font-weight: bold; cursor: pointer; margin: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); border-radius: 30px;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        .btn-blue { background: linear-gradient(135deg, #5555ff, #0000cc); }
        .btn-green { background: linear-gradient(135deg, #55ff55, #00cc00); color: black; }
        
        /* HUD */
        #game-hud { display: none; }
        .panel { background: rgba(0,0,0,0.6); padding: 10px; border-radius: 10px; color: white; backdrop-filter: blur(5px); }
        
        #top-bar { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; }
        #bottom-bar { position: absolute; bottom: 20px; width: 100%; text-align: center; display: flex; justify-content: center; gap: 20px; }
        
        #turn-indicator { 
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            font-size: 24px; font-weight: bold; text-shadow: 0 2px 4px black;
            padding: 10px 30px; border-radius: 20px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
        }

        #uno-btn { 
            width: 80px; height: 80px; border-radius: 50%; 
            background: radial-gradient(circle, #ffaa00, #ff6600);
            border: 4px solid white; font-weight: 900; color: white; font-size: 14px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 20px #ff6600;
        }
        #uno-btn.active { animation: pulse 1s infinite; background: radial-gradient(circle, #ff0000, #990000); }
        
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* MODALS */
        .modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.8); z-index: 20; display: none;
            align-items: center; justify-content: center;
        }
        .modal-content { background: #222; border: 2px solid #555; padding: 30px; border-radius: 15px; text-align: center; color: white; }
        
        .color-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .c-btn { width: 100px; height: 100px; border: none; cursor: pointer; border-radius: 10px; transition: transform 0.2s; }
        .c-btn:hover { transform: scale(1.1); }
        .c-red { background: #ff5555; } .c-yellow { background: #ffaa00; }
        .c-green { background: #55ff55; } .c-blue { background: #5555ff; }

        /* LOG */
        #game-log {
            position: absolute; bottom: 120px; left: 20px; width: 300px; height: 150px;
            overflow-y: auto; font-size: 12px; color: rgba(255,255,255,0.8);
            text-shadow: 1px 1px 2px black; pointer-events: none;
            display: flex; flex-direction: column; justify-content: flex-end;
        }
        .log-msg { margin-bottom: 4px; background: rgba(0,0,0,0.3); padding: 2px 5px; border-radius: 4px; width: fit-content; }
    </style>
</head>
<body>

    <!-- 3D CANVAS CONTAINER -->
    <div id="canvas-container"></div>

    <!-- UI LAYER -->
    <div id="ui-layer">
        
        <!-- LOBBY -->
        <div id="lobby-screen" class="interactive">
            <h1 style="font-size: 4em; margin-bottom: 0; text-shadow: 0 0 20px red;">UNO 3D</h1>
            <p style="color: #aaa; margin-bottom: 40px;">PEER-TO-PEER • OFFICIAL RULES</p>
            
            <div id="identity-select" style="text-align: center;">
                <p>SELECT IDENTITY</p>
                <div id="id-buttons"></div>
            </div>

            <div id="lobby-waiting" style="display: none; text-align: center;">
                <h2 id="my-id-display">...</h2>
                <div class="panel" style="width: 300px; min-height: 100px; margin: 20px;">
                    <h3>CONNECTED PEERS</h3>
                    <ul id="peer-list" style="list-style: none; padding: 0;"></ul>
                </div>
                <button id="btn-start" class="btn btn-green" disabled>START GAME</button>
            </div>
        </div>

        <!-- GAME HUD -->
        <div id="game-hud">
            <div id="top-bar">
                <div class="panel">Room: <span id="hud-room-id">--</span></div>
                <div class="panel">Host: <span id="hud-host-id">--</span></div>
            </div>

            <div id="turn-indicator" class="panel">
                WAITING FOR START
            </div>

            <div id="game-log"></div>

            <div id="bottom-bar" class="interactive">
                <button id="btn-draw" class="btn btn-blue">DRAW CARD</button>
                <div id="uno-btn" onclick="Game.toggleUno()">UNO!</div>
            </div>
        </div>

        <!-- MODALS -->
        <div id="color-modal" class="modal interactive">
            <div class="modal-content">
                <h2>CHOOSE COLOR</h2>
                <div class="color-grid">
                    <button class="c-btn c-red" onclick="Game.resolveColor('RED')"></button>
                    <button class="c-btn c-yellow" onclick="Game.resolveColor('YELLOW')"></button>
                    <button class="c-btn c-green" onclick="Game.resolveColor('GREEN')"></button>
                    <button class="c-btn c-blue" onclick="Game.resolveColor('BLUE')"></button>
                </div>
            </div>
        </div>

        <div id="challenge-modal" class="modal interactive">
            <div class="modal-content">
                <h2>WILD DRAW 4 PLAYED!</h2>
                <p>The previous player played a Wild Draw 4.</p>
                <p style="font-size: 0.9em; color: #aaa;">Rule: They can only play this if they have NO card matching the current color.</p>
                <br>
                <button class="btn btn-blue" onclick="Game.resolveChallenge(false)">ACCEPT (+4)</button>
                <button class="btn" onclick="Game.resolveChallenge(true)">CHALLENGE (RISK +6)</button>
            </div>
        </div>
    </div>

<script>
/**
 * ------------------------------------------------------------------
 * 1. ASSET GENERATION (Procedural Textures)
 * ------------------------------------------------------------------
 */
const TextureGen = {
    cache: {},
    
    // Draw a single UNO card texture on a canvas
    createCardTexture: function(color, type) {
        const key = `${color}_${type}`;
        if (this.cache[key]) return this.cache[key];

        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 360;
        const ctx = canvas.getContext('2d');

        // Background
        const colors = {
            'RED': '#e70000', 'YELLOW': '#f9d800', 'GREEN': '#009d00', 'BLUE': '#004ec4', 'BLACK': '#111'
        };
        
        // Card Body
        ctx.fillStyle = '#fff';
        ctx.roundRect(0, 0, 256, 360, 20);
        ctx.fill();
        ctx.fillStyle = colors[color] || '#111';
        ctx.beginPath();
        ctx.roundRect(10, 10, 236, 340, 15);
        ctx.fill();

        // Ellipse
        ctx.save();
        ctx.translate(128, 180);
        ctx.rotate(30 * Math.PI / 180);
        ctx.scale(1, 1.4);
        ctx.beginPath();
        ctx.arc(0, 0, 80, 0, Math.PI * 2);
        ctx.fillStyle = '#fff'; //(color === 'BLACK') ? '#fff' : '#fff';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.restore();

        // Text/Symbol
        ctx.fillStyle = (color === 'BLACK' || type === 'SKIP' || type === 'REVERSE') ? colors[color] : colors[color];
        if(color !== 'BLACK') ctx.fillStyle = colors[color]; // Inner text matches bg
        
        ctx.shadowBlur = 0;
        ctx.fillStyle = (color === 'BLACK') ? 'url(#grad)' : colors[color];

        // Draw Center Symbol
        this.drawSymbol(ctx, type, 128, 180, 100, color);

        // Draw Corner Symbols
        this.drawCorner(ctx, type, 25, 35, 30, color); // Top Left
        ctx.save();
        ctx.translate(231, 325);
        ctx.rotate(Math.PI);
        this.drawCorner(ctx, type, 0, 0, 30, color); // Bottom Right
        ctx.restore();

        const texture = new THREE.CanvasTexture(canvas);
        texture.anisotropy = 4;
        this.cache[key] = texture;
        return texture;
    },

    createBackTexture: function() {
        if(this.cache['BACK']) return this.cache['BACK'];
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 360;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,256,360);
        ctx.fillStyle = '#ff0000'; ctx.font = 'bold 60px Arial'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
        ctx.fillText('UNO', 128, 180);
        ctx.lineWidth = 5; ctx.strokeStyle = '#ffaa00'; ctx.strokeText('UNO', 128, 180);
        
        const tex = new THREE.CanvasTexture(canvas);
        this.cache['BACK'] = tex;
        return tex;
    },

    drawSymbol: function(ctx, type, x, y, size, color) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `bold ${size}px Arial`;
        
        // Multi-color text for Wilds
        if (color === 'BLACK') {
            const grad = ctx.createLinearGradient(x-50, y-50, x+50, y+50);
            grad.addColorStop(0, '#ff5555');
            grad.addColorStop(0.3, '#ffaa00');
            grad.addColorStop(0.6, '#55ff55');
            grad.addColorStop(1, '#5555ff');
            ctx.fillStyle = grad;
        } else {
            ctx.fillStyle = color;
            // Shadow text on white oval
            ctx.shadowColor = 'rgba(0,0,0,0.8)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
        }

        if (['0','1','2','3','4','5','6','7','8','9'].includes(type)) {
            ctx.fillText(type, x, y);
        } else if (type === 'SKIP') {
            ctx.font = `bold ${size * 0.6}px Arial`;
            ctx.fillText('⊘', x, y);
        } else if (type === 'REVERSE') {
            ctx.font = `bold ${size * 0.6}px Arial`;
            ctx.fillText('⇄', x, y);
        } else if (type === 'DRAW2') {
            ctx.fillText('+2', x, y);
        } else if (type === 'WILD') {
            ctx.font = `bold ${size*0.4}px Arial`;
            ctx.fillText('WILD', x, y);
        } else if (type === 'WILD4') {
            ctx.font = `bold ${size*0.4}px Arial`;
            ctx.fillText('+4', x, y);
        }
    },

    drawCorner: function(ctx, type, x, y, size, color) {
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${size}px Arial`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        let text = type;
        if(type === 'SKIP') text = '⊘';
        if(type === 'REVERSE') text = '⇄';
        if(type === 'WILD') text = 'W';
        if(type === 'WILD4') text = '+4';
        if(type === 'DRAW2') text = '+2';
        ctx.fillText(text, x, y);
    }
};

/**
 * ------------------------------------------------------------------
 * 2. 3D ENGINE (Three.js)
 * ------------------------------------------------------------------
 */
const Visuals = {
    scene: null, camera: null, renderer: null, raycaster: null,
    mouse: new THREE.Vector2(),
    cards: {}, // Map<CardID, Mesh>
    
    init: function() {
        // Scene Setup
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x222222);
        
        // Camera
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.set(0, 15, 10);
        this.camera.lookAt(0, 0, 0);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);

        // Lights
        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        this.scene.add(dirLight);

        // Table
        const tableGeo = new THREE.PlaneGeometry(30, 30);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.rotation.x = -Math.PI / 2;
        table.receiveShadow = true;
        this.scene.add(table);

        // Deck Placeholder
        const deckGeo = new THREE.BoxGeometry(1.6, 0.5, 2.4);
        const deckMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const deckMesh = new THREE.Mesh(deckGeo, deckMat);
        deckMesh.position.set(-2, 0.25, 0);
        this.scene.add(deckMesh);

        // Interaction
        this.raycaster = new THREE.Raycaster();
        window.addEventListener('resize', () => this.onResize());
        window.addEventListener('mousedown', (e) => this.onClick(e));
        window.addEventListener('mousemove', (e) => this.onMouseMove(e));

        this.animate();
    },

    createCardMesh: function(id, c, t) {
        if(this.cards[id]) return this.cards[id];

        const geo = new THREE.PlaneGeometry(1.6, 2.4);
        const matFront = new THREE.MeshStandardMaterial({ map: TextureGen.createCardTexture(c, t) });
        const matBack = new THREE.MeshStandardMaterial({ map: TextureGen.createBackTexture() });
        
        const group = new THREE.Group();
        
        // Front (facing +Z initially)
        const frontMesh = new THREE.Mesh(geo, matFront);
        frontMesh.castShadow = true;
        group.add(frontMesh);

        // Back (facing -Z)
        const backMesh = new THREE.Mesh(geo, matBack);
        backMesh.rotation.y = Math.PI;
        backMesh.castShadow = true;
        group.add(backMesh);

        // User Data for clicking
        frontMesh.userData = { id: id, parent: group };
        
        group.userData = { id: id, c: c, t: t };
        this.scene.add(group);
        this.cards[id] = group;
        return group;
    },

    updateState: function(state, myId) {
        // 1. Process Hand
        const myPlayer = state.players.find(p => p.id === myId);
        if(!myPlayer) return;

        // Position My Hand
        const handSize = myPlayer.hand.length;
        const arcWidth = Math.min(handSize * 1.2, 10);
        const startX = -arcWidth / 2;
        
        myPlayer.hand.forEach((card, i) => {
            const mesh = this.createCardMesh(card.id, card.c, card.t);
            const targetX = startX + (i * (arcWidth / (handSize || 1)));
            const targetY = 0.5 + (i * 0.01);
            const targetZ = 6; // Close to camera
            
            // If already at target, skip (unless animating)
            if(!mesh.userData.animating) {
                new TWEEN.Tween(mesh.position)
                    .to({ x: targetX, y: targetY, z: targetZ }, 300)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                new TWEEN.Tween(mesh.rotation)
                    .to({ x: -Math.PI / 4, y: 0, z: 0 }, 300)
                    .start();
            }
        });

        // 2. Process Discard Pile
        state.discard.forEach((card, i) => {
            const mesh = this.createCardMesh(card.id, card.c, card.t);
            const targetY = 0.01 + (i * 0.01);
            
            // Simple random rotation for realism
            if(!mesh.userData.discarded) {
                mesh.userData.discarded = true;
                const rotZ = (Math.random() - 0.5) * 0.5;
                new TWEEN.Tween(mesh.position)
                    .to({ x: 1, y: targetY, z: 0 }, 500)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
                new TWEEN.Tween(mesh.rotation)
                    .to({ x: -Math.PI/2, y: 0, z: rotZ }, 500)
                    .start();
            }
        });

        // 3. Remote Players (Simplified Stacks)
        state.players.forEach((p, idx) => {
            if(p.id === myId) return;
            // Just visualization logic for others could go here
            // For now, we focus on local hand + discard
        });

        // 4. Cleanup removed cards
        // (Simplified GC logic not shown for brevity, but needed in long games)
    },

    onClick: function(event) {
        if(Game.state.status !== 'PLAYING') return;

        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);

        // Raycast against card FRONTS only
        const meshes = Object.values(this.cards).map(g => g.children[0]);
        const intersects = this.raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
            const group = intersects[0].object.userData.parent;
            if(group) {
                Game.attemptPlay(group.userData.id, group.userData.c, group.userData.t);
            }
        }
    },
    
    onMouseMove: function(event) {
        // Hover effect logic could go here
    },

    onResize: function() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    },

    animate: function(time) {
        requestAnimationFrame((t) => this.animate(t));
        TWEEN.update(time);
        this.renderer.render(this.scene, this.camera);
    }
};

/**
 * ------------------------------------------------------------------
 * 3. LOGIC ENGINE (Rules & State)
 * ------------------------------------------------------------------
 */
const PEER_IDS = ['DevgnaVyas00', 'YashPandya11', 'PrathamSukhadia22', 'MilanSharma33', 'TirthPrajapati44', 'NishitRana55'];
const COLORS = ['RED', 'YELLOW', 'GREEN', 'BLUE'];

const Logic = {
    createDeck: () => {
        let deck = [];
        const add = (c, t, n) => { for(let i=0; i<n; i++) deck.push({ id: Math.random().toString(36).substr(2,9), c:c, t:t }); };
        COLORS.forEach(c => {
            add(c, '0', 1);
            for(let i=1; i<=9; i++) add(c, i.toString(), 2);
            add(c, 'SKIP', 2); add(c, 'REVERSE', 2); add(c, 'DRAW2', 2);
        });
        add('BLACK', 'WILD', 4); add('BLACK', 'WILD4', 4);
        // Shuffle (Fisher-Yates)
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
    },
    
    canPlay: (card, top, activeColor) => {
        if (card.c === 'BLACK') return true;
        if (card.c === (activeColor || top.c)) return true;
        if (card.t === top.t) return true;
        return false;
    }
};

const Game = {
    myId: null,
    hostId: null,
    state: null,
    unoDeclared: false,

    init: (id) => {
        Game.myId = id;
        Game.unoDeclared = false;
        Net.init(id);
        Visuals.init();
    },

    startHost: () => {
        const deck = Logic.createDeck();
        const players = Net.getConnectedIds().concat([Game.myId]).sort().map(id => ({ id: id, hand: [] }));
        
        // Deal 7
        players.forEach(p => p.hand = deck.splice(0, 7));
        
        let top = deck.shift();
        // Edge case: Start with Wild 4 -> Reshuffle
        while(top.c === 'BLACK' && top.t === 'WILD4') {
            deck.push(top);
            deck.sort(() => Math.random() - 0.5);
            top = deck.shift();
        }

        const initState = {
            ver: 1,
            deck: deck,
            discard: [top],
            players: players,
            turnIdx: 0,
            direction: 1,
            activeColor: top.c === 'BLACK' ? null : top.c,
            status: 'PLAYING', // PLAYING, CHALLENGE_WAIT, END
            challengeData: null,
            log: ['Game Started']
        };

        // Initial Card Effects
        if(top.t === 'SKIP') initState.turnIdx = 1;
        if(top.t === 'REVERSE') {
            if(players.length === 2) initState.turnIdx = 1;
            else { initState.direction = -1; initState.turnIdx = players.length - 1; }
        }
        if(top.t === 'DRAW2') {
            players[0].hand.push(deck.shift(), deck.shift());
            initState.turnIdx = 1;
            initState.log.push(`${players[0].id} drew 2 (Start Card)`);
        }

        Net.broadcast(initState);
        Game.update(initState);
    },

    update: (newState) => {
        if(Game.state && newState.ver <= Game.state.ver) return;
        Game.state = newState;
        
        // UI Updates
        Visuals.updateState(newState, Game.myId);
        
        // HUD
        document.getElementById('hud-host-id').innerText = Game.hostId;
        document.getElementById('hud-room-id').innerText = Net.getConnectedIds().length + 1;
        
        const turnPlayer = newState.players[newState.turnIdx];
        const isMyTurn = turnPlayer.id === Game.myId;
        const colorName = newState.activeColor || 'ANY';
        
        const elTurn = document.getElementById('turn-indicator');
        elTurn.innerHTML = `TURN: ${turnPlayer.id}<br><span style="color:${colorName}; font-size:0.8em">${colorName}</span>`;
        elTurn.style.borderColor = colorName;

        // Log
        const logEl = document.getElementById('game-log');
        logEl.innerHTML = newState.log.slice(-5).map(l => `<div class="log-msg">${l}</div>`).join('');

        // Modals
        if(newState.status === 'CHALLENGE_WAIT' && newState.challengeData.victim === Game.myId) {
            document.getElementById('challenge-modal').style.display = 'flex';
        } else {
            document.getElementById('challenge-modal').style.display = 'none';
        }
        
        // Controls
        document.getElementById('btn-draw').disabled = !isMyTurn || newState.status !== 'PLAYING';
        
        // Win?
        if(newState.status === 'END') {
            alert("GAME OVER! Check log for winner.");
        }
    },
    
    // Actions
    attemptPlay: (cardId, c, t) => {
        const s = Game.state;
        const me = s.players.find(p => p.id === Game.myId);
        if(s.players[s.turnIdx].id !== Game.myId) return;
        if(s.status !== 'PLAYING') return;

        const top = s.discard[s.discard.length-1];
        if(!Logic.canPlay({c,t}, top, s.activeColor)) {
            // Shake animation?
            return;
        }

        // Wild?
        if(c === 'BLACK') {
            Game.pendingCardId = cardId;
            document.getElementById('color-modal').style.display = 'flex';
            return;
        }

        Net.sendAction('PLAY', { cardId: cardId, uno: Game.unoDeclared });
        Game.unoDeclared = false;
        document.getElementById('uno-btn').classList.remove('active');
    },

    resolveColor: (color) => {
        document.getElementById('color-modal').style.display = 'none';
        Net.sendAction('PLAY', { cardId: Game.pendingCardId, color: color, uno: Game.unoDeclared });
        Game.unoDeclared = false; 
        document.getElementById('uno-btn').classList.remove('active');
    },

    resolveChallenge: (doChallenge) => {
        document.getElementById('challenge-modal').style.display = 'none';
        Net.sendAction('CHALLENGE_RESPONSE', { challenge: doChallenge });
    },

    toggleUno: () => {
        Game.unoDeclared = !Game.unoDeclared;
        const btn = document.getElementById('uno-btn');
        if(Game.unoDeclared) btn.classList.add('active');
        else btn.classList.remove('active');
    }
};

/**
 * ------------------------------------------------------------------
 * 4. NETWORKING (WebRTC + Host Authority)
 * ------------------------------------------------------------------
 */
const Net = {
    peer: null,
    conns: {},
    
    init: (id) => {
        Net.peer = new Peer(id, { debug: 1 });
        Net.peer.on('open', (id) => {
            document.getElementById('my-id-display').innerText = id;
            document.getElementById('lobby-waiting').style.display = 'block';
            document.getElementById('identity-select').style.display = 'none';
            Net.connectMesh();
            setInterval(Net.maintenance, 2000);
        });
        Net.peer.on('connection', Net.onConn);
        Net.peer.on('error', (e) => console.log(e));
    },

    connectMesh: () => {
        PEER_IDS.forEach(pid => {
            if(pid !== Game.myId) {
                const conn = Net.peer.connect(pid);
                Net.onConn(conn);
            }
        });
    },

    onConn: (conn) => {
        conn.on('open', () => {
            Net.conns[conn.peer] = conn;
            Net.updateLobby();
        });
        conn.on('data', (data) => Net.handleData(conn.peer, data));
        conn.on('close', () => { delete Net.conns[conn.peer]; Net.updateLobby(); });
    },

    handleData: (sender, data) => {
        if(data.type === 'STATE') Game.update(data.payload);
        if(data.type === 'ACTION' && Game.myId === Game.hostId) HostLogic.process(sender, data.payload);
    },

    broadcast: (state) => {
        Object.values(Net.conns).forEach(c => c.send({ type: 'STATE', payload: state }));
    },

    sendAction: (type, payload) => {
        if(Game.myId === Game.hostId) HostLogic.process(Game.myId, { type, ...payload });
        else if(Net.conns[Game.hostId]) Net.conns[Game.hostId].send({ type: 'ACTION', payload: { type, ...payload }});
    },

    maintenance: () => {
        // Host Election
        const peers = Object.keys(Net.conns).concat([Game.myId]).sort();
        const newHost = peers[0];
        if(newHost !== Game.hostId) {
            Game.hostId = newHost;
            console.log("New Host:", newHost);
            if(Game.myId === newHost && !Game.state) {
                document.getElementById('btn-start').disabled = false;
            }
        }
        // If I am host, sync state periodically
        if(Game.myId === Game.hostId && Game.state) {
             Net.broadcast(Game.state);
        }
    },
    
    updateLobby: () => {
        const list = document.getElementById('peer-list');
        list.innerHTML = Object.keys(Net.conns).map(id => `<li>${id}</li>`).join('');
        if(Object.keys(Net.conns).length > 0 && Game.myId === Game.hostId) {
            document.getElementById('btn-start').disabled = false;
        }
    },
    
    getConnectedIds: () => Object.keys(Net.conns)
};

/**
 * ------------------------------------------------------------------
 * 5. HOST LOGIC (The "Server")
 * ------------------------------------------------------------------
 */
const HostLogic = {
    process: (pid, act) => {
        let s = JSON.parse(JSON.stringify(Game.state));
        const pIdx = s.players.findIndex(p => p.id === pid);
        const player = s.players[pIdx];
        
        // Security checks
        if(s.status === 'PLAYING' && s.players[s.turnIdx].id !== pid) return;

        if(act.type === 'DRAW') {
            if(s.deck.length === 0) { // Reshuffle
                const top = s.discard.pop();
                s.deck = s.discard.sort(() => Math.random() - 0.5);
                s.discard = [top];
            }
            const card = s.deck.shift();
            player.hand.push(card);
            s.log.push(`${pid} drew card`);
            
            const top = s.discard[s.discard.length-1];
            // If unplayable, force next turn. If playable, they can play (so don't advance yet)
            if(!Logic.canPlay(card, top, s.activeColor)) {
                 HostLogic.advance(s);
            }
        }

        if(act.type === 'PLAY') {
            const cIdx = player.hand.findIndex(c => c.id === act.cardId);
            if(cIdx === -1) return;
            const card = player.hand[cIdx];
            
            // Validate Rule
            const top = s.discard[s.discard.length-1];
            if(!Logic.canPlay(card, top, s.activeColor)) return;

            // Remove card
            player.hand.splice(cIdx, 1);
            s.discard.push(card);
            s.activeColor = card.c; // Default
            if(card.c === 'BLACK') s.activeColor = act.color;

            // UNO Check
            if(player.hand.length === 1 && !act.uno) {
                s.log.push(`${pid} forgot UNO! (+2)`);
                player.hand.push(s.deck.shift(), s.deck.shift());
            } else if(player.hand.length === 1 && act.uno) {
                s.log.push(`${pid} said UNO!`);
            }

            // Win?
            if(player.hand.length === 0) {
                s.status = 'END';
                s.log.push(`${pid} WINS!`);
                Game.update(s); Net.broadcast(s); return;
            }

            // Effects
            if(card.t === 'SKIP') HostLogic.advance(s, 2);
            else if(card.t === 'REVERSE') {
                if(s.players.length === 2) HostLogic.advance(s, 2);
                else { s.direction *= -1; HostLogic.advance(s, 1); }
            }
            else if(card.t === 'DRAW2') {
                const vIdx = HostLogic.getNext(s, 1);
                s.players[vIdx].hand.push(s.deck.shift(), s.deck.shift());
                s.log.push(`${s.players[vIdx].id} +2 cards`);
                HostLogic.advance(s, 2);
            }
            else if(card.t === 'WILD4') {
                s.status = 'CHALLENGE_WAIT';
                s.challengeData = { 
                    attacker: pid, 
                    victim: s.players[HostLogic.getNext(s, 1)].id, 
                    prevColor: top.c === 'BLACK' ? (Game.state.activeColor) : top.c 
                };
                s.log.push(`Wild+4! waiting for challenge...`);
            }
            else {
                HostLogic.advance(s, 1);
            }
        }

        if(act.type === 'CHALLENGE_RESPONSE') {
            const attacker = s.players.find(p => p.id === s.challengeData.attacker);
            const victim = s.players.find(p => p.id === pid);
            
            if(act.challenge) {
                // Check if attacker had color
                const illegal = attacker.hand.some(c => c.c === s.challengeData.prevColor);
                if(illegal) {
                    s.log.push(`CHALLENGE SUCCESS! ${attacker.id} draws 4`);
                    for(let i=0;i<4;i++) attacker.hand.push(s.deck.shift());
                    HostLogic.advance(s, 1); // Turn moves to victim (who acts normally)
                } else {
                    s.log.push(`CHALLENGE FAILED! ${pid} draws 6`);
                    for(let i=0;i<6;i++) victim.hand.push(s.deck.shift());
                    HostLogic.advance(s, 2); // Victim skipped
                }
            } else {
                s.log.push(`${pid} accepted +4`);
                for(let i=0;i<4;i++) victim.hand.push(s.deck.shift());
                HostLogic.advance(s, 2); // Victim skipped
            }
            s.status = 'PLAYING';
            s.challengeData = null;
        }

        s.ver++;
        Game.update(s);
        Net.broadcast(s);
    },

    getNext: (s, step) => {
        let idx = s.turnIdx + (step * s.direction);
        const len = s.players.length;
        return ((idx % len) + len) % len;
    },

    advance: (s, step = 1) => {
        s.turnIdx = HostLogic.getNext(s, step);
    }
};

// --- BOOTSTRAP ---
const idContainer = document.getElementById('id-buttons');
PEER_IDS.forEach(id => {
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.innerText = id;
    btn.onclick = () => Game.init(id);
    idContainer.appendChild(btn);
});

document.getElementById('btn-start').onclick = () => {
    Game.startHost();
    document.getElementById('lobby-screen').style.display = 'none';
    document.getElementById('game-hud').style.display = 'block';
};

// Handle Draw
document.getElementById('btn-draw').onclick = () => Net.sendAction('DRAW');

</script>
</body>
</html>


